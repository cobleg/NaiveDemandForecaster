#
# Objective: simulate long-run demand growth for grid-delivered electricity
# Nomenclature:
#              P: price
#              Q: quantity
#              _: indicates a subscript
#              gr: growth rate (year-over-year)
#              pv: solar photovoltaic electricity generation
#              ev: electric vehicle
#              icev: internal combustion engine vehicle
#


library(cowplot)
library(ggplot2)

library(shiny)
library(zoo)

source("logisticFunction.R")
source("averageCost2.R")

# Define UI for application that creates a forecast
ui <- fluidPage(# Application title
   titlePanel("Naive Demand Forecaster"),
   
   # Sidebar with slider input
   sidebarLayout(
      sidebarPanel(
         style = "overflow-y:scroll; max-height: 600px; position:relative;",
         titlePanel("Demand growth assumptions"),
         hr(),
         sliderInput(
            "gr_pop",
            "Population growth rate:",
            min = -10,
            max = 10,
            value = 2,
            post = " %"
         ),
         sliderInput(
            "gr_Q_vehicles",
            "Vehicle stock growth rate:",
            min = -10,
            max = 10,
            value = 1.5,
            post = " %",
            step = 0.5
         ),
         sliderInput(
            "gr_P_grid",
            "Grid-delivered electricity price growth rate:",
            min = -10,
            max = 10,
            value = 2,
            post = " %"
         ),
         sliderInput(
            "gr_P_pv",
            "Solar PV price growth rate:",
            min = -10,
            max = 100,
            value = 0,
            post = " %"
         ),
         sliderInput(
            "gr_P_ICE",
            "Internal combustion engine vehicle (ICEV) total cost of ownership (TOC) growth rate",-10,
            10,
            1.5,
            post = " %"
         ),
         sliderInput(
            "gr_P_ev",
            "Electric vehicle (EV) TOC growth rate:",
            min = -10,
            max = 100,
            value = 0,
            post = " %"
         ),
         sliderInput(
            "gr_gsp",
            "Economic growth rate:",
            min = -10,
            max = 10,
            value = 2.5,
            post = " %"
         ),
         sliderInput (
            "gr_pv_sc",
            "Average solar PV self-consumption growth rate",
            0,
            10,
            1,
            post = " %"
         ),
         sliderInput(
            "gr_pv_capacity",
            "Average PV system capacity growth rate",
            0,
            25,
            0.5,
            post = " %",
            step = 0.5
         ),
         sliderInput("gr_ADMD", "After Diversity Maximum Demand", -10, 10, -1, post = " %"),
         sliderInput(
            "gr_COM",
            "Total Commercial sector demand growth rate",-10,
            10,
            0,
            post = " %"
         ),
         sliderInput(
            "gr_IND",
            "Total Industrial sector demand growth rate",-10,
            10,
            0,
            post = " %"
         ),
         hr(),
         
         sliderInput("t0_pop", "Initial population (millions)", 0, 4, 2, step = 0.5),
         sliderInput(
            "t0_Q_vehicles",
            "Initial vehicle stock (millions)",
            0,
            4,
            2.3,
            step = 0.5
         ),
         sliderInput("t0_P_grid", "Initial grid electricity price (c/kWh)", 0, 100, 28),
         sliderInput("t0_P_pv", "Initial solar PV levelised price (c/kWh) ", 0, 100, 5),
         #sliderInput("t0_Q_pv", "Initial solar PV installed base ('000s)", 1, 1000, 500),
         sliderInput("t0_P_ev", "Initial EV TOC ($/month)", 0, 1000, 245, step = 10),
         sliderInput("t0_Q_ev", "Initial EV installed base ('000s)", 0, 1000, 1),
         
         
         sliderInput(
            "t0_gsp",
            "Initial Gross State Product level ($ billions)",
            10,
            150,
            100
         ),
         sliderInput(
            "t0_pv_sc",
            "Initial average solar PV self-consumption as a proportion of total output (%)",
            0,
            100,
            25,
            post = " %"
         ),
         sliderInput(
            "t0_pv_capacity",
            "Initial average PV system capacity (kWh)",
            0,
            25,
            3
         ),
         sliderInput("t0_ADMD", "After Diversity Maximum Demand (kW", 0, 20, 4),
         sliderInput(
            "t0_COM_GWh",
            "Initial total Commercial sector demand (TWh)",
            0,
            100,
            8
         ),
         sliderInput(
            "t0_IND_GWh",
            "Initial total Industrial sector demand (TWh)",
            0,
            100,
            7
         ),
         sliderInput(
            "t0_P_ICE",
            "Initial ICE total cost of ownership ($/month)",
            0,
            1000,
            312,
            step = 10
         ),
         hr(),
         # sliderInput("E_house", "Demand elasticity w.r.t. housing", 0, 1, 0.1, step = 0.01),
         # sliderInput("E_pv", "Grid price elasticity for solar PV w.r.t. solar PV installations", -1, 1, 0.01, step = 0.01),
         # sliderInput("E_ev", "Demand elasticity w.r.t. electric vehicles", 0, 1, 0.1),
         sliderInput(
            "E_price",
            "Demand elasticity w.r.t. the retail electricity price",
            -5,
            0,
            -0.3,
            step = 0.01
         ),
         # sliderInput("E_gsp", "Demand elasticity w.r.t. economic output", 0, 1, 0.1, step = 0.01),
         # hr(),
         sliderInput(
            "t0_household_occupancy",
            "Average persons per household",
            0,
            10,
            2,
            step = 0.1
         ),
         sliderInput(
            "t0_cars_per_house",
            "Average cars per household",
            0,
            5,
            2.6,
            step = 0.1
         ),
         sliderInput(
            "tN_pv_pen_ratio",
            "Eventual ratio of homes with solar PV to total homes",
            0,
            1,
            0.8
         ),
         
         sliderInput("forecast_horizon", "Forecast horizon (years)", 5, 100, 50)
      ),
      
      # Show a plot of the generated distribution
      mainPanel(# tableOutput("n")
         # tableOutput("m"),
         # tableOutput("table_demand_drivers"),
         # tableOutput("table_demand"),
         plotOutput("Plot_Demand"),
         plotOutput("Plot_Drivers"))
   ))

# Define server logic required to draw a histogram
server <- function(input, output) {
   m <-
      reactive({
         # create a dataframe containing naive forecasts for each demand driver
         growth <- matrix(0, nrow = 1, ncol = 12)
         
         growth[1, 1] <- (input$gr_pop) / 100 + 1
         growth[1, 2] <-
            (input$gr_P_pv) / 100 + 1     # this now relates to price, not quantity
         growth[1, 3] <-
            (input$gr_P_ev) / 100 + 1     # this now relates to price, not quantity
         growth[1, 4] <- (input$gr_P_grid) / 100 + 1
         growth[1, 5] <- (input$gr_gsp) / 100 + 1
         growth[1, 6] <- input$gr_pv_sc / 100 + 1
         growth[1, 7] <- input$gr_pv_capacity / 100 + 1
         growth[1, 8] <- input$gr_ADMD / 100 + 1
         growth[1, 9] <- input$gr_COM / 100 + 1
         growth[1, 10] <- input$gr_IND / 100 + 1
         growth[1, 11] <- input$gr_P_ICE / 100 + 1
         growth[1, 12] <- input$gr_Q_vehicles / 100 + 1
         
         base <- matrix(0, nrow = 1, ncol = 12)
         
         base[1, 1] <- input$t0_pop
         base[1, 2] <- input$t0_P_pv / 100
         base[1, 3] <- input$t0_P_ev
         base[1, 4] <- input$t0_P_grid / 100
         base[1, 5] <- input$t0_gsp
         base[1, 6] <- input$t0_pv_sc / 100
         base[1, 7] <- input$t0_pv_capacity
         base[1, 8] <- input$t0_ADMD
         base[1, 9] <- input$t0_COM_GWh
         base[1, 10] <- input$t0_IND_GWh
         base[1, 11] <- input$t0_P_ICE
         base[1, 12] <- input$t0_Q_vehicles * 1e6
         
         m <- matrix(1,
                     nrow = input$forecast_horizon,
                     ncol = ncol(base))
         m[1,] <- base
         for (i in 2:input$forecast_horizon) {
            m[i,] <-  m[i - 1,] * growth
         }
         
         m <-
            data.frame(
               "Index" = seq.int(nrow(m)),
               m,
               "P_grid_pv" = m[, 4] / m[, 2],
               "P_EV_ICEV" = m[, 3] / m[, 11]
            )
         names(m) <-
            c(
               "Index",
               # 1
               "pop",
               # 2
               "P_PV",
               # 3
               "P_EV",
               # 4
               "P_grid",
               # 5
               "gsp",
               # 6
               "pv_sc",
               # 7
               "pv_cap",
               # 8
               "ADMD",
               # 9
               "COM_GWh",
               # 10
               "IND_GWh",
               # 11
               "P_ICE",
               # 12
               "Q_vehicles",
               # 13
               "P_grid_pv",
               # 14
               "P_EV_ICEV"   # 15
            )
         
         return(m)
      })
   
   output$m <- renderTable({
      m()
   })
   
   # calculate the number of households
   Q_house <- reactive({
      m_1 <- m()
      pop <- m_1$pop
      household_number <-  pop * 1e6 / input$t0_household_occupancy
   })
   
   output$n <- renderTable({
      Q <- as.numeric(Q_house())
      nrow(Q)
   })
   
   
   # Calculate the quantity of generated electricity from the average solar PV system
   pv_kWh <- reactive({
      m_2 <- m()
      pv_capacity <- m_2$pv_cap
      # output per pv system per year (kWh) = 8 hours per day x 365 days per year x pv capacity
      pv_output <- 8 * 365 * pv_capacity
   })
   
   # calculate the quantity of solar PV installations
   Q_pv <- reactive({
      m <- m()
      Q_house <- as.numeric(Q_house())
      
      
      # calculate growth rate for logistic function based on relative levelised cost of solar PV to grid electricity
      Q_PV = logistic(
         c = 1,
         p = m$P_grid_pv,
         alpha = 0.5,
         p0 = m$P_grid_pv[1]
      ) * Q_house
      
   })
   
   # calculate the quantity of total solar PV generated electricity in the system
   pv_GWh <- reactive({
      # pv output (GWh) = pv_kWh x solar_pv (quantity of systems) / 1e6
      pv_GWh <- (pv_kWh() * Q_pv()) / 1e6
   })
   
   # calculate the quantity of total solar PV generated electricity consumed to offset grid supply
   pv_sc <- reactive({
      # pv exports = pv output (GWh) x self-consumption
      m_2 <- m()
      pvGWh <- pv_GWh()
      return(pvGWh * m_2$pv_sc)
   })
   
   # Calculate the underlying household demand for electricity
   Q_ud_house_GWh <- reactive({
      m <- m()
      
      Q_ud <- (m$ADMD * 365 * Q_house()) / 1e6
   })
   
   # Calculate the grid price series
   price_grid <- reactive({
      m <- m()
      Q_GWh <- Q_ud_house_GWh()
      
      AC <-
         averageCost2(GWh_1 = Q_GWh ,
                      dataPoints = input$forecast_horizon)
      Price <- AC
      
      #Price <- m$P_grid
      return(Price)
   })
   
   # Calculate the residual demand for grid-delivered electricity
   Q_house_GWh <- reactive({
      m <- m()
      Q_h <- Q_house()
      pv_sc <- pv_sc()
      load_factor <- 0.5
      Q_GWh <- Q_ud_house_GWh() - pv_sc()
      price <- price_grid()
      lprice <- log(price)
      pct_change_price <- diff(zoo(lprice), 1, na.pad = T)
      pct_change_price[is.na(pct_change_price)] <- 0
      pct_change_GWh <- input$E_price * pct_change_price * 2e2
      Q_GWh2 <- (pct_change_GWh + 1) * Q_GWh
      return(Q_GWh2)
   })
   
   # forecast the quantity of electric vehicles based on relative total cost of ownership of ICEVs to EVs
   Q_EV <- reactive({
      m <- data.frame (m())
      
      c = 1 # represents the steady state market share of EVs in total vehicles
      p <- m$P_ICE  /  m$P_EV        # relative price of ICE to EVs
      p0 = m$P_ICE[1]  / (m$P_EV[1])  # initial price ratio of ICEVs to EVs
      ev <-
         logistic(
            c = c,
            p = p,
            alpha = 0.9,
            p0 = p0
         ) *
         (logistic(
            c = 1,
            p = m$Index,
            p0 = 0,
            alpha = 0.05
         ) - 0.5) * m$Q_vehicles # logistic function calculates the share of EVs to ICE vehicles
      return(ev)
      
   })
   
   Q_EV_GWh <- reactive({
      Q_EV_kWh_daily <- 20 # Daily EV demand for electricity per vehicle
      s_EV_grid <-
         0.5 # share of daily EV demand supplied by the grid
      Q_EV_kWh_daily * s_EV_grid * Q_EV() / 1e3 # total EV grid electricity demand (GWh)
   })
   
   # calculate the demand forecast based on the input drivers
   Q_grid <- reactive({
      # Calculate total demand
      m_3 <- m()
      
      COM_GWh <- m_3$COM
      IND_GWh <- m_3$IND
      Q_h <- Q_ud_house_GWh()
      Q_ud <-
         as.numeric(Q_ud_house_GWh() + COM_GWh * 1e3 + IND_GWh * 1e3 + Q_EV_GWh())
      Q_grid <-
         as.numeric(Q_house_GWh()  + COM_GWh * 1e3 + IND_GWh * 1e3 + Q_EV_GWh())
      Q_grid <-
         data.frame(
            "Years" = seq.int(length(Q_grid)),
            "Demand" = Q_grid,
            "Houses.UD" = Q_ud
         )
      
      return(Q_grid)
   })
   
   
   
   output$table_demand <- renderTable({
      Q_grid()
      
   })
   
   # create a dataframe of demand driver forecasts
   demand_drivers <- reactive({
      Q <- Q_grid()
      dd <-
         data.frame(
            m(),
            "Demand" = Q$Demand,
            "Demand.Houses" = Q$Houses.UD,
            "Prices.Grid" = as.numeric(price_grid()),
            "Houses" = Q_house() / 1e6,
            "Q_PV" = Q_pv() / 1e6,
            "PV.Total.GWh" = pv_GWh(),
            "PV_GWh" = pv_sc(),
            
            "Q_EV" = Q_EV() / 1e6
         )
      return(dd)
   })
   
   output$table_demand_drivers <- renderTable({
      demand_drivers()
   })
   
   # Plot the demand
   output$Plot_Demand <- renderPlot({
      Q_grid <- Q_grid()
      Plot_Demand <-
         ggplot(Q_grid, aes(x = Years)) + ggtitle("Demand for grid-delivered electricity") + xlab("Forecast timeframe") + ylim(0, max(Q_grid$Demand))
      Plot_Demand <-
         Plot_Demand + geom_line(aes(y = Demand)) + ylab("GWh")
      return(Plot_Demand)
   })
   
   output$Plot_Drivers <- renderPlot({
      gsp <- ggplot(demand_drivers(), aes(x = Index))
      gsp <- gsp + geom_line(aes(y = gsp)) + ylab("GSP ($ bill.)")
      gsp <-
         gsp + ggtitle("Economic output (Gross State Product)") + xlab("Forecast timeframe")
      pv <-
         ggplot(demand_drivers(), aes(x = Index, y = Q_PV)) + geom_line() + ggtitle("Solar PV installations") + xlab("Forecast timeframe") + ylab("Installations (mill.)")
      house <-
         ggplot(demand_drivers(), aes(x = Index, y = Houses)) + geom_line() + ggtitle("Number of households") + xlab("Forecast timeframe") + ylab("Houses (mill.)")
      
      P_grid <-
         ggplot(demand_drivers(), aes(x = Index, y = Prices.Grid)) + geom_line() + ggtitle("Grid electricity price") + xlab("Forecast timeframe") + ylab("$/kWh")
      P_PV <-
         ggplot(demand_drivers(), aes(x = Index, y = P_PV)) + geom_line() + ggtitle("Solar PV levelised electricity price") + xlab("Forecast timeframe") + ylab("$/kWh")
      P_grid_PV <-
         ggplot(demand_drivers(), aes(x = Index, y = P_grid_pv)) + geom_line() + ggtitle("Relative grid price to solar PV") + xlab("Forecast timeframe") + ylab("Index")
      
      Q_EV <-
         ggplot(demand_drivers(), aes(x = Index, y = Q_EV)) + geom_line() + ggtitle("Electric vehicles (EVs)") + xlab("Forecast timeframe") + ylab("Vehicles (mill.)")
      P_EV_ICEV <-
         ggplot(demand_drivers(), aes(x = Index, y = P_EV_ICEV)) + geom_line() + ggtitle("Total Cost of Ownership: EVs to ICEVs") + xlab("Forecast timeframe") + ylab("Index")
      
      return(plot_grid(
         gsp,
         P_grid,
         P_PV,
         P_grid_PV,
         house,
         pv,
         Q_EV,
         P_EV_ICEV,
         ncol = 2
      ))
      
   })
}

# Run the application
shinyApp(ui = ui, server = server)
